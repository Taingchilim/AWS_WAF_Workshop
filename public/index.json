[
{
	"uri": "/3-custom-rules/1-challenges/",
	"title": "ACLs and Rules Challenge",
	"tags": [],
	"description": "",
	"content": "Contents:\n Challenge Configuration: Create custom rule Test Case  Challenge Just as you thought you had solved your milkshake fiasco, more malicious requests are targeting your application. The attacks have become more specific. You realise you can block these attacks with a custom rule for your WAF Web ACL. All of the attacks seem to contain a strange header, X-TomatoAttack. Blocking requests with that header will stop the attack\n\r\rSelect to see a hint\r\r\r Create a new custom rule The malicious requests contain a specific header. How long is the value of this header?  \r Configuration: Create custom rule Create a rule on your Web ACL that blocks requests with the header X-TomatoAttack with ANY value.\n\r\rSelect to see the steps\r\r\r Add a Custom Rule to your Web ACL  Inspect the Header of the request Add a Custom Rule to your Web ACL Inspect the Header of the request If the Header X-TomatoAttack \u0026gt;= 0, block the request.  \r You could also achieve the same goal using a regular expression.\nIf you rule is not working, double check:\n The web ACL is associated with the Application Load Balancer The header field name is spelt correctly  Test Case This test case will send a request your test application. If the WAF rule is working, your request should be blocked. You will receive a 403 response like below\n\u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=iso-8859-1\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;ERROR: The request could not be satisfied\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;403 ERROR\u0026lt;/h1\u0026gt;\r\u0026lt;!-- Omitted --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rRun the command below in your terminal.\n# Set the JUICESHOP_URL variable if not already done\r# JUICESHOP_URL=\u0026lt;Your Juice Shop URL\u0026gt;\r# This should be blocked\rcurl -H \u0026#34;X-TomatoAttack: Red\u0026#34; \u0026#34;${JUICESHOP_URL}\u0026#34;\r# This should be blocked\rcurl -H \u0026#34;X-TomatoAttack: Green\u0026#34; \u0026#34;${JUICESHOP_URL}\u0026#34;\rCheck your WebACL overview to see the sampled requests. You should see these requests marked as BLOCK.\nPhew, it seems like your custom rule worked.\nCustom rules allow you to implement your own logic for handling requests in WAF. Custom rules can inspect many components of a request, then act to block or allow a request if the rule statement is true.\nEvery Web ACL has a maxiumum Web ACL Capacity Units (WCU). This is 1500, but can be increased if needed. Every rule and rule group in a Web ACL contributes towards this limit.\n"
},
{
	"uri": "/4-advanced-rules/1-challenges/",
	"title": "Advanced Rule Challenge",
	"tags": [],
	"description": "",
	"content": "Contents:\n Challenge Update JSON Rule Test Case  Challenge The milkshake bandits are back attacking your workshop. They’ve changed their attack again! You’ll need to create a new rule to block these requests, whilst allow genuine customers For this challenge, you start with an existing rule.\n\r\rSelect to see your starting rule\r\r\r{\r\u0026#34;Name\u0026#34;: \u0026#34;complex-rule-challenge\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;complex-rule-challenge\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;OrStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleHeader\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;x-milkshake\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;chocolate\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r},\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleQueryArgument\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;milkshake\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;banana\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r]\r}\r}\r}\r\r\r Currently it will block any requests that either:\n Contain the header x-milkshake: chocolate Contain the query parameter milkshake=banana  This rule was working, but the attackers have adapted. Now malicious requests contain either\n The header x-milkshake: chocolate AND the header x-favourite-topping: nuts The query parameter milkshake=banana AND the query parameter favourite-topping=sauce  Update the existing rule. Use AndStatement to extend the two existing statements. AndStatement has the following syntax:\n\u0026#34;AndStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r# Add your statements here\r]\r}\rUpdate JSON Rule \r\rSelect to see the JSON rule\r\r\r{\r\u0026#34;Name\u0026#34;: \u0026#34;complex-rule-challenge\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;complex-rule-challenge\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;OrStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r\u0026#34;AndStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleHeader\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;x-milkshake\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;chocolate\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r},\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleHeader\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;x-favourite-topping\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;nuts\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r]\r}\r},\r{\r\u0026#34;AndStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleQueryArgument\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;milkshake\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;banana\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r},\r{\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleQueryArgument\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;favourite-topping\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;sauce\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r]\r}\r}\r]\r}\r}\r}\r\r Test Case Test your new rule by creating the following requests using curl.\n# Set the JUICESHOP_URL if not already done\rJUICESHOP_URL=\u0026lt;Your Juice Shop URL\u0026gt;\r# Allowed\rcurl -H \u0026#34;x-milkshake: chocolate\u0026#34; \u0026#34;${JUICESHOP_URL}\u0026#34;\rcurl \u0026#34;${JUICESHOP_URL}?milkshake=banana\u0026#34;\r# Blocked\rcurl -H \u0026#34;x-milkshake: chocolate\u0026#34; -H \u0026#34;x-favourite-topping: nuts\u0026#34; \u0026#34;${JUICESHOP_URL}\u0026#34;\rcurl \u0026#34;${JUICESHOP_URL}?milkshake=banana\u0026amp;favourite-topping=sauce\u0026#34;\rBlocked requests will give a response like below\n\u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=iso-8859-1\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;ERROR: The request could not be satisfied\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;403 ERROR\u0026lt;/h1\u0026gt;\r\u0026lt;!-- Omitted --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rIn this section, you learnt about the JSON format for WAF Rules. Complex logic can be defined in rules using the And, Or and Not operators.\n"
},
{
	"uri": "/",
	"title": "AWS Web Application Firewall",
	"tags": [],
	"description": "",
	"content": "What is AWS WAF? AWS WAF is a web application firewall service. It helps protect your web applications or APIs against common web exploits that may affect availability, compromise security, or consume excessive resources.\nUsing a WAF is a great way to add defense in depth to your web application. A WAF can help mitigate the risk of vulnerabilities such as SQL Injection, Cross Site Scripting and other common attacks (which listed in Top 10 OWASP). WAF allows you to create your own custom rules to decide whether to block or allow HTTP requests before they reach your application.\nContents We devided this lab into sections below:\n Prerequiste Web ACLs and Managed Rules Custom Rules Advanced Custom Rules Testing New Rules Logging Cleanup  "
},
{
	"uri": "/5-testing/1-challenges/",
	"title": "Challenge",
	"tags": [],
	"description": "",
	"content": "Contents:\n Challenge Configuration: Update your current Rule and Test Test case  Challenge You have developed a new rule for your WAF. Before you can deploy it, you must first test it. This is to reduce the risk of unintentionally introducing rules that block genuine requests.\nThe rule below blocks requests with the query parameter username.\nRead more about testing Web ACLs\n\r\rSelect to see hints\r\r\r Update the rule Action of the rule below to Count, so that it can be tested.  {\r\u0026#34;Name\u0026#34;: \u0026#34;count-von-count\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;count-von-count\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;SizeConstraintStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleQueryArgument\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;username\u0026#34;\r}\r},\r\u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GT\u0026#34;,\r\u0026#34;Size\u0026#34;: \u0026#34;0\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r}\rDeploy the rule to your web ACL, using either to the console or the CLI.  \r Configuration: Update your current Rule and Test \r\rSelect to see steps\r\r\r Update the rule Action of the rule below to Count  {\r\u0026#34;Name\u0026#34;: \u0026#34;count-von-count\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Count\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;count-von-count\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;SizeConstraintStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleQueryArgument\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;username\u0026#34;\r}\r},\r\u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GT\u0026#34;,\r\u0026#34;Size\u0026#34;: \u0026#34;0\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r}\rCreate a new rule in Console, change to JSON editor and paste above rule into the editor. Send few request with query parameter username to your web application. Navigate to CloudWatch Metrics page. Select AWS/WAFv2, then Region \u0026gt; Rule \u0026gt; WebACL to view the CloudWatch Metrics.  \r Test case Execute the following command in your terminal.\ncurl \u0026#34;$JUICESHOP_URL?username=admin\u0026#34;\rThis request won’t be blocked. Instead, it should be counted. Check CloudWatch metrics to see if it has worked!\n"
},
{
	"uri": "/6-logging/1-challenges/",
	"title": "Logging Challenge",
	"tags": [],
	"description": "",
	"content": "Contents:\n Challenge Configuration: Logging Conclusion  Challenge  The Juice Shop is growing rapidly. Great work! Now that you have a set of rules, it is becoming more difficult to reason which rule is responsible for blocking a request. It would be helpful to have some logs. To do this, you need to enable logging for your Web ACL to an S3 Bucket. Your logs contain a sensitive header, named Cookie. You don’t want this to be stored in your logs. You will need configure the redaction of this header in the logs.\n Use Logging Web ACL Traffic Information to help you\n\r Create an S3 bucket. This will be the destination of your Kinesis Data Firehose  Prefix the S3 bucket with aws-waf-logs-workshop-. This is to help you find it later.    When using a Kinesis Data Firehose to ingest WAF requests, the Firehose name must have the prefix aws-waf-logs-\n\rCreate a Kinesis Data Firehose delivery stream. Make sure to create the resource in us-east-1. This is required when capturing logs for CloudFront.  Prefix the Kinesis Data Firehose with aws-waf-logs-workshop-. This is required by the WAF service Use the S3 bucket from the previous step as your destination.   Enable logging for your WAF Redact the cookie, titled Cookie (the Juice Shop Cookie) in your logs. Generate some traffic using the following requests. Some of these will be blocked by the rules you’ve previously created  curl \u0026#34;$JUICESHOP_URL?username=admin\u0026#34;\rcurl \u0026#34;${JUICESHOP_URL}?milkshake=banana\u0026amp;favourite-topping=sauce\u0026#34;\rcurl -H \u0026#34;x-milkshake: chocolate\u0026#34; \u0026#34;${JUICESHOP_URL}\u0026#34;\rDownload the log file from the S3 bucket used as the Kinesis Data Firehose destination. Inspect the logs. Can you find the redacted Cookie field? View the redacted fields for a logging configuration with the get-logging-configuration CLI command\n\r  Configuration: Logging \r\rSelect to see the answer\r\r\r Create a Kinesis Data Firehose in us-east-1. Make sure the name begins with aws-waf-logs-. For example, aws-waf-logs-workshop. Select S3 as the Firehose destination.  Select your Web ACL in the WAF Console Select the Logging and Metrics Tab Select Enable logging  Select the Kinesis Date Firehose you wish to use. Under Redacted Fields, tick Header. Add the Header value Cookie  Run the curl commands in the challenge above to generate traffic  Download the log files from S3.  Search for the Cookie header in the log file  \r Conclusion WAF allows you to capture request logs and store them in any Kinesis Data Firehose destination. The logs provide information of the request. The logs also provide the action and rule involved for a request. This information can be invaluable when running a WAF. Use field redaction to avoid logging sensitive information.\n"
},
{
	"uri": "/1-prerequiste/",
	"title": "Prerequiste",
	"tags": [],
	"description": "",
	"content": "Contents:\n Setting up The Juice Shop Deploy the sample Web App  Setting up This workshop requires an AWS Account.\n\rMac and Linux OS\n The AWS CLI may be useful, but is not mandatory  The AWS CLI will make it quick to deploy custom rules later in the workshop Make sure the AWS CLI is updated to the latest version    Windows\n This workshop uses curl to create and send HTTP requests. These are to test the WAF rules. curl is present on Windows Subsystem For Linux.  If you are unsure, you are recommended to use a AWS Cloud9 dev environment to complete this workshop. The Cloud9 environment contains all the tools required. The default settings when creating a Cloud9 environment are suitable for this workshop\n\rThe Juice Shop AWS WAF is used by attaching it to another AWS Resource: either a CloudFront distribution, Application Load Balancer, or API Gateway that is associated with your web application.\nIn order to test your WAF, you will need an application!\nIn this workshop you will use the OWASP Juice Shop. The Juice Shop is an Open Source web application that is intentionally insecure.\nPwning OWASP Juice Shop is a free book that explains the app and its vulnerabilities in more detail.\nDeploy the sample Web App Choose a region to deploy the Sample Web App to, and follow the appropriate link from the table below.\nThis CloudFormations tack will take approximately 5 minutes to complete.\n   Region Launch Template     US East (N. Virginia) (us-east-1)    US East (Ohio) (us-east-2)    US West(Oregon) (us-west-2)    EU (Ireland) (eu-west-1)    EU (London) (eu-west-2)     \r\rLaunch Templates\r\r\reu-west-1.template\r\r(3 ko)\r\r\reu-west-2.template\r\r(3 ko)\r\r\rus-east-1.template\r\r(3 ko)\r\r\rus-east-2.template\r\r(3 ko)\r\r\rus-west-2.template\r\r(3 ko)\r\r\r\rStep by step instructions:\n If desired, provide your stack with a unique name. Be careful not to exceed the 64-character stack name limit  Click the Next button at the bottom of the remaining pages, using the default values.  On the final page, ensure the tickboxes allowing AWS CloudFormation to create IAM resources with custom names are ticked.  Click the orange “Create stack” button at the bottom-right of the page to deploy the stack into your account.  CloudFormation will now deploy the Juice Shop application into your account. Wait until all stacks are shown in a CREATE_COMPLETE state.\n\rFind the JuiceShopUrl value in the CloudFormation template output. This is the address of your Juice Shop site.  Set the JUICESHOP_URL variable in your terminal. You will use this variable for running test requests against your WAF.  export JUICESHOP_URL=\u0026lt;Your JuiceShopUrl CloudFormation Output\u0026gt;\rYou can try to browse your web application.\nUse the AWS WAF documentation to help!\n\r"
},
{
	"uri": "/2-acls-managed-rules/1-challenges/",
	"title": "Web ACLs and Managed Rules",
	"tags": [],
	"description": "",
	"content": "Contents:\n Challenges Configuration: Create Web ACL Configuration: Adding Managed Rule Group Test Case  Challenges You are the sole developer for the start up Juice Shop. Your website is a simple web application backed by a SQL Database. For some reason, a group of Milkshake bandits have started attacking your site!\nLuckily, you recently attended a workshop on AWS WAF. You decide to implement your own WAF to protect your site.\nAt this time, you don’t have much time, so you decide to deploy two AWS Managed Rule groups to your WebACL. This will protect your website from the common attacks the milkshake bandits are using.\nConfiguration: Create Web ACL Create a web ACL in the WAF console.\n\r\rSelect to see the steps\r\r\r Navigate to the AWS WAF Console. Select Create Web ACL. Set the Region to the Global (CloudFront).  Set the name to waf-workshop-juice-shop. Set the description as web ACL for the aws-waf-workshop. Leave the Resource type as CloudFront Distribution.    In the Associated AWS resources section, select Add AWS resources.  Select the CloudFront distribution.  \r Associate the web ACL with the CloudFront distribution for your site.\n\r\rSelect to see notices\r\r\rIf the CloudFront distribution does not appear when associating it to the web ACL, double check that:\n The web ACL Resource type is set to CloudFront Distribution. The CloudFormation template in Part 1 - Prerequiste has been deployed successfully.  \r Configuration: Adding Managed Rule Group Add two managed rule groups to your WebACL.\n\r\rSelect to see the steps\r\r\r Navigate to the Rules tab of your web ACL. Select Add Rules \u0026gt; Add Managed Rule Groups.  Select Core Rule Set and SQL Database from the AWS managed rule groups.  Select Add rules to add rule to your Web ACL. Select Next in Step 3 and Step 4. Finally, select Create web ACL in Step 5 to create Web ACL.  \r Test Case Test your new rules with the commands below. Make sure the JUICESHOP_URL variable to contains the URL for your Juice Shop deployment.\nexport JUICESHOP_URL=\u0026lt;Your Juice Shop URL\u0026gt;\r# This imitates a Cross Site Scripting attack\r# This request should be blocked.\rcurl -X POST $JUICESHOP_URL -F \u0026#34;user=\u0026#39;\u0026lt;script\u0026gt;\u0026lt;alert\u0026gt;Hello\u0026gt;\u0026lt;/alert\u0026gt;\u0026lt;/script\u0026gt;\u0026#39;\u0026#34;\r# This imitates a SQL Injection attack\r# This request should be blocked.\rcurl -X POST $JUICESHOP_URL -F \u0026#34;user=\u0026#39;AND 1=1;\u0026#34;\r If a request is blocked, you will receive a HTML response stating the request was forbidden. Here’s an snippet of what to expect  \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=iso-8859-1\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;ERROR: The request could not be satisfied\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;403 ERROR\u0026lt;/h1\u0026gt;\r\u0026lt;!-- Omitted --\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r If you receive a response like below, then the request wasn’t blocked by WAF.  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt;\r\u0026lt;title\u0026gt;OWASP Juice Shop\u0026lt;/title\u0026gt;\r// Omitted for brevity\r\u0026lt;/head\u0026gt;\r\u0026lt;/html\u0026gt;\rIn this case, something has gone wrong. Double check the following:\n Is your web ACL associated with the CloudFront distribution?  The CloudFront distribution will not be protected if the web ACL is not associated.   Does your web ACL contain two active rules, the Core Rule Set and Sql database?  If the managed rules are not active, then no rules will exist in the web ACL to block the request.    "
},
{
	"uri": "/2-acls-managed-rules/",
	"title": "Web ACLs and Managed Rules",
	"tags": [],
	"description": "",
	"content": "Contents:\n Web ACLs Managed Rules  Web ACLs A web ACL (Web Access Control List) is the core resource in an AWS WAF deployment. It contains rules that are evaluated for each request that it receives. A web ACL is associated to your web application via either an Amazon CloudFront distribution, AWS API Gateway API or an AWS Application Load Balancer.\nThis workshop uses the latest version of AWS WAF. Make sure you do not use WAF Classic.\n\rManaged Rules The quickest way to get started with WAF is to deploy an AWS Managed Rule Group for AWS WAF to your WebACL.\nManaged Rule Groups are a set of rules, created and maintained by AWS or third-parties on the AWS Marketplace. These rules provide protections against common types of attacks, or are intended for particular application types.\nEach managed rule group protects against a set of common attacks, such as SQL or Command Line attacks.\nAWS provide a selection of managed rule groups. Three examples are the Amazon IP Reputation list, Known Bad Inputs and Core rule set. There are other rule groups available to use\n"
},
{
	"uri": "/3-custom-rules/",
	"title": "Custom Rules",
	"tags": [],
	"description": "",
	"content": "Contents:\n Custom Rule Create Custom Rule Request Sampling Web ACL Capacity Units  Custom Rule WAF allows you to create your own rules for handling requests. This is useful for adding logic relevant for your specific application. Alongside custom rules, this section will introduce request sampling and Web ACL Capacity Units.\nCreate Custom Rule The simplest way to create a custom rule is to use the Editor in the WAF Console.\nRules allow you to inspect components of a the HTTP request such as:\n Source IP Headers Body URI Query Parameters  Based on the component inspected, you can block or allow a request.\nRequest Sampling WAF allows you to view a sample of requests that it has processed. Do this from your Web ACL dashboard\nThis is useful for quick debugging to see what requests have been received and how they were handled.\nIt’s also possible to log all requests your Web ACL receives. This will be introduced later\nWeb ACL Capacity Units Your web ACL has a maxiumum WCU of 1500. This can be increased by contacting AWS Support.\n\rMore details about WCU.\n"
},
{
	"uri": "/4-advanced-rules/",
	"title": "Advanced Custom Rules",
	"tags": [],
	"description": "",
	"content": "You’ve created a simple WAF rule that evaluates one part of a request. How could you create a rule to evaulate multiple parts of a request?\nContents:\n Rules in JSON Boolean Logic in Rules Example  Rules in JSON All WAF Rules are defined as JSON objects. For complex rules, it can be more efficient to work directly with the JSON format than via the Console rules editor. You can retrieve existing rules in JSON format using the API, CLI or Console using the get-rule-group command. Modify them using your favourite JSON text editor, then reupload them using update-rule-group in the API, CLI or Console.\nDefining rules in JSON allows you to use version control as a source of truth to see how, when and why iterations of complex rulesets have changed.\nThe syntax for defining rules in JSON is provided in the update-rule-group documentation\n\rIf you’re ever unsure of the syntax, it can be helpful to create a simple example in the Console visual editor first, then switch to the JSON editor to see the JSON equivalent.\nBoolean Logic in Rules The AND, OR and NOT operators can be used to create more complex rules. This is useful to inspect multiple parts of a request. For example, you could only allow a request if the query string OR the Header contains a certain key/value.\nNested rules can be created using the visual editor. However, they are limited to one level deep. To create arbitarily nested rules in the console, the JSON editor must be used. Use the validate action in the console JSON editor to validate the rule\n\rBelow is an example of a rule created in the console. This rule will block requests with a query string of length greater than or equal to 0.\nThis rule will block any request containing a query string.\n\rHere is the same rule defined in JSON\n Action specifies the action taken by WAF if the rule evaluates to true. VisibilityConfig is used to configure request sampling and CloudWatch metrics. Statement defines the rule expression to be evaluated.  {\r\u0026#34;Name\u0026#34;: \u0026#34;example-rule-01\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;example-rule-01\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;SizeConstraintStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;QueryString\u0026#34;: {}\r},\r\u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GT\u0026#34;,\r\u0026#34;Size\u0026#34;: \u0026#34;0\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r}\rExample You’ve been asked by your favourite colleague for some help. They are recieving an attack. They need to block malicious incoming requests without blocking requests from actual customers. The malicious requests contain a body over 100kb, but are missing a header, x-upload-photo: true.\nYou quickly realise that this isn’t possible to express using the console rule editor. You will need to edit some JSON.\nLet’s start with an empty rule:\n{\r\u0026#34;Name\u0026#34;: \u0026#34;example-rule-02\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;example-rule-02\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r// We will add the rule here\r}\r}\rThere are two cases we need to consider\n If the request body is larger than 100kb, block the request If the request does not contain a header of x-upload-body: true, block the request  We will need to use the OrStatement and NotStatement to express this logic.\n{\r// fields omitted for brevity\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;OrStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r// Inspect Body Size here\r},\r{\r\u0026#34;NotStatement\u0026#34;: {\r// Inspect Header here\r}\r}\r]\r}\r}\rTo inspect the size of the body, we will use the SizeConstraintStatement to validate the size of the request body.\n\u0026#34;SizeConstraintStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;Body\u0026#34;: {}\r},\r\u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GT\u0026#34;,\r\u0026#34;Size\u0026#34;: \u0026#34;100\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\rTo inspect the Headers of the request, use the ByteMatchStatement\n\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleHeader\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;x-upload-image\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;true\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\rHere is the final rule\n{\r\u0026#34;Name\u0026#34;: \u0026#34;complex-rule-example\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0,\r\u0026#34;Action\u0026#34;: {\r\u0026#34;Block\u0026#34;: {}\r},\r\u0026#34;VisibilityConfig\u0026#34;: {\r\u0026#34;SampledRequestsEnabled\u0026#34;: true,\r\u0026#34;CloudWatchMetricsEnabled\u0026#34;: true,\r\u0026#34;MetricName\u0026#34;: \u0026#34;complex-rule-example\u0026#34;\r},\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;OrStatement\u0026#34;: {\r\u0026#34;Statements\u0026#34;: [\r{\r\u0026#34;SizeConstraintStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;Body\u0026#34;: {}\r},\r\u0026#34;ComparisonOperator\u0026#34;: \u0026#34;GT\u0026#34;,\r\u0026#34;Size\u0026#34;: \u0026#34;100\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r},\r{\r\u0026#34;NotStatement\u0026#34;: {\r\u0026#34;Statement\u0026#34;: {\r\u0026#34;ByteMatchStatement\u0026#34;: {\r\u0026#34;FieldToMatch\u0026#34;: {\r\u0026#34;SingleHeader\u0026#34;: {\r\u0026#34;Name\u0026#34;: \u0026#34;x-upload-body\u0026#34;\r}\r},\r\u0026#34;PositionalConstraint\u0026#34;: \u0026#34;EXACTLY\u0026#34;,\r\u0026#34;SearchString\u0026#34;: \u0026#34;true\u0026#34;,\r\u0026#34;TextTransformations\u0026#34;: [\r{\r\u0026#34;Type\u0026#34;: \u0026#34;NONE\u0026#34;,\r\u0026#34;Priority\u0026#34;: 0\r}\r]\r}\r}\r}\r}\r]\r}\r}\r}\r"
},
{
	"uri": "/5-testing/",
	"title": "Testing New Rules",
	"tags": [],
	"description": "",
	"content": "Before deploying a new rule, it’s vital to test it. This is to ensure you don’t accidentally block valid requests.\nSo far you have used Block and Allow when specifying what action to take on a request. There is a third action, Count. Count allows you to measure the number of requests that would meet the rule conditions.\nCount is a non-terminating action. When a request matches a rule with the Count action, the web ACL will continue processing the remaining rules.\nManaged rules and rule groups can also be tested in a similar way using Count.\n\rContents\n Viewing rule counts  Viewing rule counts When a rule with action Count is matched, the event is emitted as CloudWatch metrics. To view the count for a rule, navigate to the CloudWatch metrics console. Select AWS/WAFv2, then Region, Rule, WebACL to view you metrics.\nBy default, Average is used when displaying WAF metrics. It’s useful to change this to Sum in some scenarios.\n\r"
},
{
	"uri": "/6-logging/",
	"title": "Logging",
	"tags": [],
	"description": "",
	"content": "WAF Uses Amazon Kinesis Firehose to ingest logs. This allows logs to be passed to any Kinesis Firehose destination, such as Amazon S3, Amazon Redshift or Amazon Elastic Search. To enable logging of requests in your Web ACL, you must first create a Kinesis Data Firehose.\nContent\n WAF Log Example Analysing and Visualising Logs  WAF Log Example Here is an example WAF log of a request. Note that you receive details on the rule that terminated the evaluation of the request. The log also contains the action taking on that request\n{\r\u0026#34;timestamp\u0026#34;: 1576280412771,\r\u0026#34;formatVersion\u0026#34;: 1,\r\u0026#34;webaclId\u0026#34;: \u0026#34;arn:aws:wafv2:ap-southeast-2:EXAMPLE12345:regional/webacl/STMTest/1EXAMPLE-2ARN-3ARN-4ARN-123456EXAMPLE\u0026#34;,\r\u0026#34;terminatingRuleId\u0026#34;: \u0026#34;STMTest_SQLi_XSS\u0026#34;,\r\u0026#34;terminatingRuleType\u0026#34;: \u0026#34;REGULAR\u0026#34;,\r\u0026#34;action\u0026#34;: \u0026#34;BLOCK\u0026#34;,\r\u0026#34;terminatingRuleMatchDetails\u0026#34;: [\r{\r\u0026#34;conditionType\u0026#34;: \u0026#34;SQL_INJECTION\u0026#34;,\r\u0026#34;location\u0026#34;: \u0026#34;HEADER\u0026#34;,\r\u0026#34;matchedData\u0026#34;: [\u0026#34;10\u0026#34;, \u0026#34;AND\u0026#34;, \u0026#34;1\u0026#34;]\r}\r],\r\u0026#34;httpSourceName\u0026#34;: \u0026#34;-\u0026#34;,\r\u0026#34;httpSourceId\u0026#34;: \u0026#34;-\u0026#34;,\r\u0026#34;ruleGroupList\u0026#34;: [],\r\u0026#34;rateBasedRuleList\u0026#34;: [],\r\u0026#34;nonTerminatingMatchingRules\u0026#34;: [],\r\u0026#34;httpRequest\u0026#34;: {\r\u0026#34;clientIp\u0026#34;: \u0026#34;1.1.1.1\u0026#34;,\r\u0026#34;country\u0026#34;: \u0026#34;AU\u0026#34;,\r\u0026#34;headers\u0026#34;: [\r{\r\u0026#34;name\u0026#34;: \u0026#34;Host\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;localhost:1989\u0026#34;\r},\r{\r\u0026#34;name\u0026#34;: \u0026#34;User-Agent\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;curl/7.61.1\u0026#34;\r},\r{\r\u0026#34;name\u0026#34;: \u0026#34;Accept\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;*/*\u0026#34;\r},\r{\r\u0026#34;name\u0026#34;: \u0026#34;x-stm-test\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;10 AND 1=1\u0026#34;\r}\r],\r\u0026#34;uri\u0026#34;: \u0026#34;/foo\u0026#34;,\r\u0026#34;args\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;httpVersion\u0026#34;: \u0026#34;HTTP/1.1\u0026#34;,\r\u0026#34;httpMethod\u0026#34;: \u0026#34;GET\u0026#34;,\r\u0026#34;requestId\u0026#34;: \u0026#34;rid\u0026#34;\r}\r}\rAnalysing and Visualising Logs Log analysis is key to ensure the effectiveness of WAF Rules, in addition to troubleshooting of individual issues. Logs exported to Amazon Elastic Search Service can be queried. Kibana can be used alongside Amazon Elastic Search to visualise the WAF logs S3 Select can be used to perform SQL queries against individual WAF Log files in S3. Queries can be performed in the console, or using the AWS CLI or SDKs.\nFor example, the following S3 Select query counts how many requests in the log file were blocked.\nSELECT *\rFROM S3Object s\rWHERE s.\u0026#34;action\u0026#34; = \u0026#39;BLOCK\u0026#39;\r/*\rResult:\r{\r\u0026#34;count\u0026#34;: 18\r}\r*/\r"
},
{
	"uri": "/7-clean-up/",
	"title": "Cleaning Up",
	"tags": [],
	"description": "",
	"content": "Before you finish this workshop, please make sure to delete the resources you no longer need.\nHere are the list of resources you will have created in this workshop.\n Sample Web Application WAF web ACL Kinesis Data Firehose S3 Bucket  Below are instructions on how to delete these resources.\nSample Web Application The Sample Web Application is contained is defined as a CloudFormation stack, titled WAFWorkshopSampleWebApp.\nFollow the steps in Deleting a CloudFormation Stack.\nThe WAFWorkshopSampleWebApp is a nested stack. By deleting the top level stack, the nested stacks contained will also be removed.\n\rWAF web ACL Follow the steps in Deleting a Web ACL.\nKinesis Data Firehose  Navigate to the Kinesis console Select the Data Firehose tab. If you cannot see the resource, double check your region. This resource should be in us-east-1. This may differ from the region used for the Web App deployment Delete the Data Firehose you created earlier. It will have the prefix aws-waf-logs-workshop-  S3 Bucket  Navigate to the S3 Console. Select the bucket used as the Kinesis Data Firehose destination. It will have the prefix aws-waf-logs-workshop- If you cannot see the resource, double check your region. This resource should be in us-east-1. This may differ from the region used for the Web App deployment Delete the contents of the bucket. Delete the bucket.  "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]